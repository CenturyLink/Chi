/*
 Library declaration.
  Notes:
  identifier includes the version of the library (git tag / branch)
  remote includes the repository git url
  credentialsId needs to be of the type SSH key in Jenkins
  _ at the end of the declaration loads the whole library

  This section always runs in the master jenkins.
*/
try {
  library(
        identifier: 'jsl-jenkins-shared-library-local@release/20220117',
        retriever: modernSCM(
          [
            $class: 'GitSCMSource',
            remote: "/app/jenkins/git/jsl-jenkins-shared-library.git",
            extensions: [[$class: 'WipeWorkspace']]
          ]
        )
      ) _
} catch (Exception Ex) {
  library(
        identifier: 'jsl-jenkins-shared-library@release/20220117',
        retriever: modernSCM(
          [
            $class: 'GitSCMSource',
            remote: "https://github.com/CenturyLink/jsl-jenkins-shared-library.git",
            credentialsId: 'SCMAUTO_GITHUB',
            extensions: [[$class: 'WipeWorkspace']]
          ]
        )
      ) _
}


pipeline {

    environment {


      //  Credentials:
      //  GITHUB_TOKEN_CREDENTIALS github token, jenkins user password credential. SCMAUTO_GITHUB contains the GitHub token from SCMAuto user, which need to have access to the repository.
      //  GITHUB_SSH_CREDENTIALS github ssh private key, jenkins private key credential. SCMAUTO_SSH_DEVOPS_PIPELINE contains the SSH key from SCMAuto user, which need to have access to the repository.
      //  DOCKER_CREDENTIALS Docker access info, jenkins secret file credential with environment variables to export.
      //  KUBE_CREDENTIALS Kubernetes access info, jenkins secret file credential with environment variables to export. For PRs.
      //  KUBE_CREDENTIALS_TEST Kubernetes access info, jenkins secret file credential with environment variables to export. For branches.
      //  AMAZON_CREDENTIALS AWS access info, jenkins secret file credential with environment variables to export
      //  SONARQUBE_CREDENTIALS Sonarqube access info, jenkins secret text
      //  GCP_CREDENTIALS GCP access info, jenkins secret file credential with environment variables to export
      //  JIRA_CREDENTIALS Jira access info, jenkins secret file credential with environment variables to export
      //  MORPHEUS_CREDENTIALS Morpheus access info, jenkins secret text
      //  MSTEAMS_CREDENTIALS MS Teams access info, jenkins secret text
      //  QUALITY_GATE_CREDENTIALS Credentials to gather all the contract validation gates expected to be crossed.
      //  PROJECT_MAL The MAL of the project
      GITHUB_TOKEN_SHELL_CREDENTIALS = 'allyourbotsarebelongtous-token'
      GITHUB_TOKEN_CREDENTIALS = 'GITHUB_APP_CREDENTIALS'
      GITHUB_SSH_CREDENTIALS = 'SCMAUTO_SSH_DEVOPS_PIPELINE'
      GITHUB_ALTER_CREDENTIALS = 'JANITOKEN'
      DOCKER_CREDENTIALS = 'nexus-secrets'
      DOCKER_LOGIN_CREDENTIALS = 'docker-login-user-pass'
      KUBE_CREDENTIALS = 'kube-secret'
      KUBE_CREDENTIALS_TEST = 'kube-secret-test'
      AMAZON_CREDENTIALS = 'awsCredentialsPR'
      AMAZON_CREDENTIALS_PR = 'awsCredentials'
      SONARQUBE_CREDENTIALS = 'sonar-credentials'
      GCP_CREDENTIALS = ''
      JIRA_CREDENTIALS = 'jira-credentials'
      MSTEAMS_CREDENTIALS = 'TEAMS-SECRET'
      QUALITY_GATE_CREDENTIALS = 'CRUMBS-FILE'
      //Deployment control credentialsId
      AUTHORIZED_USERS = ''
      DEPLOY_AUTH_TOKEN = ''
      NEXUS_NPM_CREDENTIALS = 'nexus-npm-secret'

      // Custom project variables
      // Add
      PROJECT_NAME = 'ux-chi'
      PROJECT_MAL = "chi"
      DOCKER_REPO = 'chi'

      BRANCH_NAME = GIT_BRANCH.split('/')[-1].trim().toLowerCase()
      COMMIT_ID = GIT_COMMIT.substring(0,7).trim().toLowerCase()
      PULL_REQUEST="pr-${env.CHANGE_ID}"
      IMAGE_NAME = "${env.PROJECT_NAME}"
      IMAGE_TAG = "${env.PULL_REQUEST}"
      KUBE_DOCKER_SECRET_NAME = "${env.PROJECT_NAME}-${env.PULL_REQUEST}"
      KUBE_DOCKER_SECRET_NAME_TEST = "${env.PROJECT_NAME}-${env.BRANCH_NAME}"
      PROD_BRANCH="master"

      // ServiceNow Variables
      SERVICE_NOW_CREDENTIALS = 'snow-credentials'
      SERVICE_NOW_HOST = 'mysupportdesk.service-now.com'
      DEVOPS_GCR_PREPROD_PAYLOAD = '{"u_implementers": "AC04119,AC59437,AC75080", "u_testers": "AB62977"}'

      RC_TAG_PATTERN =  /(.*##RC##.*)/
      PROMOTE_TAG_PATTERN =  /(.*##PROMOTE##.*)/
      DEPLOY_TAG_PATTERN =  /(.*##DEPLOYMENT##.*)/
      DOCKER_REGISTRY = 'https://nexusprod.corp.intranet:4567'
    }


    // Add parameters if needed or if deployment control is in place.
    // parameters {
    //      //https://www.jenkins.io/doc/book/pipeline/syntax/#parameters
    //  text(name: 'GCR', defaultValue: '', description: 'Enter the GCR description. Only used in deployment to production stage.')
    //  text(name: 'VERSION', defaultValue: '', description: 'Version to deploy. Only used in deployment to production stage.')
    // }



    // https://www.jenkins.io/doc/book/pipeline/syntax/#agent
    //Add agent sections in stages/stage if needed.

    agent {
        label 'Docker-enabled'
    }

    options {

      // https://www.jenkins.io/doc/book/pipeline/syntax/#options

      timestamps ()
      timeout(time: 1, unit: 'HOURS')
      buildDiscarder(logRotator(numToKeepStr:'10', daysToKeepStr: '30'))
      preserveStashes(buildCount: 10)
      disableConcurrentBuilds()
    }


    // https://www.jenkins.io/doc/book/pipeline/syntax/#triggers

    triggers {
      issueCommentTrigger('.*test this please.*')
    }

    stages {
      stage('Summary') {
        steps {
          script {
            printSummary()
          }
        }
      }
      stage('Promote and Deployment tagging') {
        when {
            tag pattern: RC_TAG_PATTERN, comparator: "REGEXP"
        }
        steps {
          script {
            createTagging()
          }
        }
      }
      stage('Authorize - Prod only') {
        when {
          tag pattern: DEPLOY_TAG_PATTERN, comparator: "REGEXP"
        }
        steps {
          script {
            echo "Gotta get the credentials for this"
            // jslDeploymentControlKnob()
          }
        }
      }
      stage('Static Code Analysis') {
        parallel {
          stage('Linting Standard CHI') {
            agent {
              dockerfile {
                filename 'Dockerfile'
                dir 'cicd/docker/sonar-scanner'
                label 'Docker-enabled'
                args '-m 2G --shm-size=2gb'
                // registryUrl DOCKER_REGISTRY
                // registryCredentialsId DOCKER_CREDENTIALS
              }
            }
            when {
              beforeAgent true
              allOf {
                  not {branch PROD_BRANCH}
                  not {tag pattern: DEPLOY_TAG_PATTERN, comparator: "REGEXP"}
                  not {tag pattern: RC_TAG_PATTERN, comparator: "REGEXP"}
              }
            }
            steps {
              script{
                jslYarnWrapper('install')
                jslNpmWrapper('run lint:css')
              }
            }
          }
          stage('Linting Chi-vue') {
            agent {
              dockerfile {
                filename 'Dockerfile'
                dir 'cicd/docker/chi-vue'
                label 'Docker-enabled'
                args '-m 2G --shm-size=2gb'
                // registryUrl DOCKER_REGISTRY
                // registryCredentialsId DOCKER_CREDENTIALS
              }
            }
            when {
              beforeAgent true
              allOf {
                  not {branch PROD_BRANCH}
                  not {tag pattern: DEPLOY_TAG_PATTERN, comparator: "REGEXP"}
                  not {tag pattern: RC_TAG_PATTERN, comparator: "REGEXP"}
              }
            }
            steps {
              script{
                dir ('src/chi-vue') {
                  jslYarnWrapper('install')
                  jslNpmWrapper('run prettier:checker')
                }
                echo "No full linting implemented in repo"
              }
            }
          }
          stage('DevSecOps') {
            when {
                allOf {
                  not { tag pattern: RC_TAG_PATTERN, comparator: "REGEXP"}
                  not { tag pattern: PROMOTE_TAG_PATTERN, comparator: "REGEXP"}
                }
            }
            steps {
              script {
                jslGitHubSecurityAlert()
              }
            }
          }
          stage('Package Version') {
            when {
              anyOf {
                branch PROD_BRANCH
                tag pattern: DEPLOY_TAG_PATTERN, comparator: "REGEXP"
              }
            }
            steps {
              script {
                check_package()
                stash name: "VERSION_BUMP", includes: "version_bump"
                stash name: "VERSION_BUMP_VUE_CHI", includes: "version_bump_vue_chi"
              }
            }
          }
        }
      }
      stage('CE & Vue Build') {
        when {
            allOf {
              not {tag pattern: RC_TAG_PATTERN, comparator: "REGEXP"}
              not {tag pattern: PROMOTE_TAG_PATTERN, comparator: "REGEXP"}
            }
        }
        parallel {
          stage ('Building Custom elements') {
            agent {
              dockerfile {
                filename 'Dockerfile'
                dir 'cicd/docker/sonar-scanner'
                label 'Docker-enabled'
                args '-m 2G --shm-size=2gb'
                // registryUrl DOCKER_REGISTRY
                // registryCredentialsId DOCKER_CREDENTIALS
              }
            }
            steps {
              script {
                dir('src/custom-elements') {
                  jslYarnWrapper('install')
                  jslNpmWrapper('run build')
                  stash name: "DIST-CHI-CE", includes: "dist/**"
                  stash name: "NODEMODULES-CHI-CE", includes: "node_modules/**"
                }
              }
            }
          }
          stage ('Building Chi-vue') {
            agent {
              dockerfile {
                filename 'Dockerfile'
                dir 'cicd/docker/chi-vue'
                label 'Docker-enabled'
                args '-m 2G --shm-size=2gb'
                // registryUrl DOCKER_REGISTRY
                // registryCredentialsId DOCKER_CREDENTIALS
              }
            }
            steps {
              script {
                dir('src/chi-vue') {
                  jslYarnWrapper('install')
                  jslNpmWrapper('run build:component')
                  stash name: "DIST-CHI-VUE", includes: "dist/**"
                  jslNpmWrapper('run build:umd')
                  stash name: "DIST-CHI-VUE-UMD", includes: "umd/**"
                  stash name: "NODEMODULES-CHI-VUE", includes: "node_modules/**"
                }
              }
            }
          }
        }
      }
      stage ('Building Chi') {
        agent {
          dockerfile {
            filename 'Dockerfile'
            dir 'cicd/docker/sonar-scanner'
            label 'Docker-enabled'
            args '-m 2G --shm-size=2gb'
            // registryUrl DOCKER_REGISTRY
            // registryCredentialsId DOCKER_CREDENTIALS
          }
        }
        when {
            allOf {
              not {tag pattern: RC_TAG_PATTERN, comparator: "REGEXP"}
              not {tag pattern: PROMOTE_TAG_PATTERN, comparator: "REGEXP"}
            }
        }
        steps {
          script {
            buildChi()
          }
        }
      }
      stage ('Cleaning reports & test folders before testing') {
        agent {
          dockerfile {
            filename 'Dockerfile'
            dir 'cicd/docker/sonar-scanner'
            label 'Docker-enabled'
            args '-m 2G --shm-size=2gb'
            // registryUrl DOCKER_REGISTRY
            // registryCredentialsId DOCKER_CREDENTIALS
          }
        }
        when {
            allOf {
              not {tag pattern: RC_TAG_PATTERN, comparator: "REGEXP"}
              not {tag pattern: PROMOTE_TAG_PATTERN, comparator: "REGEXP"}
            }
        }
        steps {
          script {
            sh script: """
              rm -rf reports test/bitmaps_test
            """, label: "Cleaning reports & test folders"
          }
        }
      }
      stage ('Tests') {
        when {
            beforeAgent true
            allOf {
              not {tag pattern: RC_TAG_PATTERN, comparator: "REGEXP"}
              not {tag pattern: PROMOTE_TAG_PATTERN, comparator: "REGEXP"}
              not {tag pattern: DEPLOY_TAG_PATTERN, comparator: "REGEXP"}
            }
        }
        parallel {
          stage ('BackstopJS Responsive Test') {
            agent {
              dockerfile {
                filename 'Dockerfile'
                dir 'cicd/docker/sonar-scanner'
                label 'Docker-enabled'
                args '-m 2G --shm-size=2gb'
                // registryUrl DOCKER_REGISTRY
                // registryCredentialsId DOCKER_CREDENTIALS
              }
            }
            steps {
              script {
                runBackstopjsResponsiveTest()
              }
            }
          }
          stage ('BackstopJS Non-Responsive Test') {
            agent {
              dockerfile {
                filename 'Dockerfile'
                dir 'cicd/docker/sonar-scanner'
                label 'Docker-enabled'
                args '-m 2G --shm-size=2gb'
                // registryUrl DOCKER_REGISTRY
                // registryCredentialsId DOCKER_CREDENTIALS
              }
            }
            steps {
              script {
                runBackstopjsNonResponsiveTest()
              }
            }
          }
          stage ('BackstopJS Custom Elements Test') {
            agent {
              dockerfile {
                filename 'Dockerfile'
                dir 'cicd/docker/sonar-scanner'
                label 'Docker-enabled'
                args '-m 2G --shm-size=2gb'
                // registryUrl DOCKER_REGISTRY
                // registryCredentialsId DOCKER_CREDENTIALS
              }
            }
            steps {
              script {
                runBackstopjsCustomElementsTest()
              }
            }
          }
          stage ('Cypress local Testing') {
            agent {
              dockerfile {
                filename 'Dockerfile'
                dir 'cicd/docker/sonar-scanner'
                label 'Docker-enabled'
                args '-m 2G --shm-size=2gb'
                // registryUrl DOCKER_REGISTRY
                // registryCredentialsId DOCKER_CREDENTIALS
              }
            }
            steps {
              script {
                runCypressLocalTesting()
              }
            }
          }
        }
      }
      stage('Coverage') {
        agent {
          dockerfile {
            filename 'Dockerfile'
            dir 'cicd/docker/sonar-scanner'
            label 'Docker-enabled'
            // registryUrl DOCKER_REGISTRY
            // registryCredentialsId DOCKER_LOGIN_CREDENTIALS
          }
        }
        when {
          beforeAgent true
          allOf {
              not {tag pattern: RC_TAG_PATTERN, comparator: "REGEXP"}
              not {tag pattern: PROMOTE_TAG_PATTERN, comparator: "REGEXP"}
              not {tag pattern: DEPLOY_TAG_PATTERN, comparator: "REGEXP"}
          }
        }
        steps {
          script {
            // jslYarnWrapper('install')
            // sh "rm -rf .nyc_output*"
            // sh "rm -rf coverage/"
            // unstash name: "NYC_OUTPUT_UNIT"
            // unstash name: "NYC_OUTPUT_E2E"
            // jslNpmWrapper('run cover:merge')
            // archiveArtifacts artifacts: '.nyc_output/**'
            // jslNpmWrapper('run cover:report:jenkins || echo Error when evaluating coverage report!')
            // stash name: "COVERAGE", includes: "coverage/**"
            // archiveArtifacts artifacts: 'coverage/**'
            jslQualityGateCodeCoverage('./cicd/docker/SonarQube/sonar-project.properties')
          }
        }
      }
      stage('Coverage upload to Sonarqube') {
        agent {
          dockerfile {
            filename 'Dockerfile'
            dir 'cicd/docker/sonar-scanner'
            label 'Docker-enabled'
            // registryUrl DOCKER_REGISTRY
            // registryCredentialsId DOCKER_LOGIN_CREDENTIALS
          }
        }
        when {
            beforeAgent true
            allOf {
              not {tag pattern: RC_TAG_PATTERN, comparator: "REGEXP"}
              not {tag pattern: PROMOTE_TAG_PATTERN, comparator: "REGEXP"}
              not {tag pattern: DEPLOY_TAG_PATTERN, comparator: "REGEXP"}
            }
        }
        steps {
          script {
            uploadCoverageToSonarqube()
          }
        }
      }
      stage('Quality Gate Check'){
        agent {
          dockerfile {
            filename 'Dockerfile'
            dir 'cicd/docker/sonar-scanner'
            label 'Docker-enabled'
            // registryUrl DOCKER_REGISTRY
            // registryCredentialsId DOCKER_LOGIN_CREDENTIALS
          }
        }
        when {
            beforeAgent true
            allOf {
              not {tag pattern: RC_TAG_PATTERN, comparator: "REGEXP"}
              not {tag pattern: PROMOTE_TAG_PATTERN, comparator: "REGEXP"}
              not {tag pattern: DEPLOY_TAG_PATTERN, comparator: "REGEXP"}
            }
        }
        steps {
          script {
            jslQualityGate()
          }
        }
      }
      stage('QualityGate1') {
          agent {
              dockerfile {
                filename 'Dockerfile'
                dir 'cicd/docker/qualitygate'
                label 'Docker-enabled'
              }
          }
          when {
              beforeAgent true
              allOf {
                not {tag pattern: RC_TAG_PATTERN, comparator: "REGEXP"}
                not {tag pattern: PROMOTE_TAG_PATTERN, comparator: "REGEXP"}
                not {tag pattern: DEPLOY_TAG_PATTERN, comparator: "REGEXP"}
              }
          }
          steps {
              script {
                  runQualityGate1()
              }
          }
      }
      stage('Version check & Publish') {
        when {
          beforeAgent true
          allOf {
              tag pattern: DEPLOY_TAG_PATTERN, comparator: "REGEXP"
              expression {
                return isVersionBump()
              }
          }
        }
        stages {
          stage('GitHub Release') {
            agent {
              dockerfile {
                filename 'Dockerfile'
                dir 'cicd/docker/sonar-scanner'
                label 'Docker-enabled'
              }
            }
            steps {
              script {
                runGitHubRelease()
              }
            }
          }
        }
      }
      stage('Publish Chi-Vue') {
        when {
          beforeAgent true
          branch 'chi-vue'
        }
        parallel {
          stage('to GitHub') {
            agent {
              dockerfile {
                filename 'Dockerfile'
                dir 'cicd/docker/chi-vue'
                label 'Docker-enabled'
              }
            }
            steps {
              script {
                dir('src/chi-vue') {
                  jslYarnWrapper('install')
                  jslNpmWrapper('run build:component')
                  jslNpmPublish(false, env.GITHUB_ALTER_CREDENTIALS)
                }
              }
            }
          }
          stage('to Nexus') {
            agent {
              dockerfile {
                filename 'Dockerfile'
                dir 'cicd/docker/chi-vue'
                label 'Docker-enabled'
              }
            }
            steps {
              script {
                dir('src/chi-vue') {
                  chiVueNexusPublish()
                }
              }
            }
          }
        }
      }
      stage ('Publish DEV to S3/Prod to AssetsServer') {
        parallel {
          stage ('Publish Dev build') {
            when {
              beforeAgent true
              allOf {
                not {branch PROD_BRANCH}
                not {tag pattern: RC_TAG_PATTERN, comparator: "REGEXP"}
                not {tag pattern: PROMOTE_TAG_PATTERN, comparator: "REGEXP"}
                not {tag pattern: DEPLOY_TAG_PATTERN, comparator: "REGEXP"}
              }
            }
            steps {
              script {
                publishToS3()
              }
            }
          }
          stage ('Publish Dev build to k8s') {
            when {
              beforeAgent true
              allOf {
                not {tag pattern: RC_TAG_PATTERN, comparator: "REGEXP"}
                not {tag pattern: PROMOTE_TAG_PATTERN, comparator: "REGEXP"}
                not {tag pattern: DEPLOY_TAG_PATTERN, comparator: "REGEXP"}
              }
            }
            steps {
              script {
                publishToK8s()
              }
            }
          }
          stage ('Publish AssetServer Build') {
            when {
              beforeAgent true
              anyOf {
                branch PROD_BRANCH
                tag pattern: DEPLOY_TAG_PATTERN, comparator: "REGEXP"
              }
            }
            agent {
              dockerfile {
                filename 'Dockerfile'
                dir 'cicd/docker/sonar-scanner'
                label 'Docker-enabled'
                // registryUrl DOCKER_REGISTRY
                // registryCredentialsId DOCKER_LOGIN_CREDENTIALS
              }
            }
            steps {
              script {
                publishAssetServerBuild()
              }
            }
          }
        }
      }
      stage('Smoke Tests') {
        agent {
          dockerfile {
            filename 'Dockerfile'
            dir 'cicd/docker/sonar-scanner'
            label 'Docker-enabled'
            // registryUrl DOCKER_REGISTRY
            // registryCredentialsId DOCKER_LOGIN_CREDENTIALS
          }
        }
        when {
          beforeAgent true
          tag pattern: DEPLOY_TAG_PATTERN, comparator: "REGEXP"
        }
        steps {
          script {
            runSmokeTests()
          }
        }
      }
      

      stage('Create PR') {
        agent {
          docker {
            image "nexusprod.corp.intranet:4567/pomicroappbase/node12:1.0.2"
            label 'Docker-enabled'
          }
        }
        steps {
          script {
            try {
              if ( BRANCH_NAME == PROD_BRANCH ) {
                createPRInShellVueChi()
                createPRInShellChi()
              }
            } catch (Exception e) {
              echo "The creation of PRs in the shell failed! Error message: ${e.getMessage()}"
            }
          }
        }
      }

      stage('Adoption Stats') {
        agent {
          dockerfile {
            filename 'Dockerfile'
            dir 'cicd/docker/jira'
            label 'Docker-enabled'
            // registryUrl DOCKER_REGISTRY
            // registryCredentialsId DOCKER_LOGIN_CREDENTIALS
          }
        }
        when {
            beforeAgent true
            allOf {
              not {tag pattern: RC_TAG_PATTERN, comparator: "REGEXP"}
              not {tag pattern: PROMOTE_TAG_PATTERN, comparator: "REGEXP"}
            }
        }
        steps {
          script {
            runAdoptionStats()
          }
        }
      }
    }
    post {
      /*
      https://www.jenkins.io/doc/book/pipeline/syntax/#post

      Always post somewhere the watermark:
    - md5sum of Jenkinsfile
    - Output of the Jenkinsfile checker output
      */
      success {
        jslNotification('success')
        jslGitHubMessage("You can check this PRs instance in https://${GIT_COMMIT}-chi-pr.enterprise.ctl.io (external) and in https://nginx-${BRANCH_NAME == 'master' ? BRANCH_NAME : PULL_REQUEST}-ux-chi.kubeodc-test.corp.intranet/ (internal)", env.CHANGE_ID)
      }
      failure {
        script {
          def gcrInProgress = env.TAG_NAME==null?env.GCR_NUMBER:env.TAG_NAME
          if (gcrInProgress) {
            echo "DEVOPS GCR of ${gcrInProgress} will be updated as cancelled / backed out. Please review your backout plan!!!"
            env.DEVOPS_GCR_PREPROD_BRANCH = 'master'
            jslGCRDevOpsFallbackUpdate("The job ${env.BUILD_URL} failed unexpectly")
          }
          jslNotification('failure')
        }
      }
      unstable {
        jslNotification('unstable')
      }
    }
  }

def isVersionBump() {
  try {
    unstash name: "VERSION_BUMP"
  } catch (Exception e) {
    echo "No VERSION_BUMP done"
    return false
  }
  def versionBump = readFile file: "version_bump"
  echo "Publish condition: GIT_BRANCH is _${env.GIT_BRANCH.trim().toLowerCase()}_"
  echo "Publish condition: currentResult is _${currentBuild.currentResult.toLowerCase()}_"
  echo "Publish condition: versionBump is _${versionBump.trim()}_"
  def isVersionBumpResult = true
  isVersionBumpResult = isVersionBumpResult && versionBump.trim() == "yes"
  isVersionBumpResult = isVersionBumpResult && currentBuild.currentResult.toLowerCase() == "success"
  isVersionBumpResult = isVersionBumpResult && ( ['origin/master', 'origin/main', 'master', 'main', PROD_BRANCH].contains(env.GIT_BRANCH.trim().toLowerCase()) || (env.TAG_NAME && env.TAG_NAME.toString().indexOf("##DEPLOYMENT##") != -1))
  return isVersionBumpResult
}

def chiVueNexusPublish() {
    jslYarnWrapper('install')
    jslNpmWrapper('run build:component')
    // skipping errors temporarily to allow existing publishing on GitHub
    try {
      configFileProvider([configFile(fileId: 'NEXUS_NPMRC', targetLocation: '.npmrc', variable: 'NEXUS_NPMRC'),
                          configFile(fileId: 'INTERNAL_CERT_CHAIN', targetLocation: 'internal-ca.pem', variable: 'INTERNAL_CERT_CHAIN')]) {
        sh "sed -i -e 's/\"name\": \"@centurylink/\"name\": \"@chi/g' package.json"
        def commitJson = readJSON file: "package.json"
        def versionExists = ''
        try {
            versionExists = npmNexusWrapper("info ${commitJson.name}@${commitJson.version} version")
        } catch (Exception e) {
            echo "package not found, first time publish? Error message: ${e.getMessage()}"
        }
        echo "package.json version '${commitJson.version}', version found on repo '${versionExists}'"
        if (versionExists.trim() != commitJson.version) {
            npmNexusWrapper("publish --verbose --access restricted")
        } else {
            echo "version ${commitJson.version} is already published, skipping"
        }
        sh "sed -i -e 's/\"name\": \"@chi/\"name\": \"@centurylink/g' package.json"
      }
    } catch (Exception e) {
      echo "An error ocurred while publishing chi-vue to Nexus: ${e.getMessage()}"
    }
}

def npmNexusWrapper(def args) {
	withCredentials([string(credentialsId: NEXUS_NPM_CREDENTIALS, variable: 'NEXUS_TOKEN')]) {
    def output = sh script: """
        set +x
        export NEXUS_TOKEN=${NEXUS_TOKEN}
        npm ${args}
    """, label: "npm ${args}", returnStdout: true
    return output
  }
}

def printSummary() {
  def chivueProjectJson = readJSON file: 'src/chi-vue/package.json', returnPojo: true;
  env.CHIVUE_PACKAGE_SCOPE = chivueProjectJson['name'].split('/')[0].replaceFirst("@", "")
  env.GITHUB_ORGANIZATION = jslGitGetRepoOwner()

  echo """
  PROJECT_NAME: ${env.PROJECT_NAME}
  GIT_BRANCH: ${env.GIT_BRANCH}
  GIT_COMMIT: ${env.GIT_COMMIT}
  BRANCH_NAME: ${env.BRANCH_NAME}
  COMMIT_ID: ${env.COMMIT_ID}
  PULL_REQUEST: ${env.PULL_REQUEST}
  CHANGE_ID: ${env.CHANGE_ID}
  TAG: ${env.TAG_NAME}

  CHIVUE_PACKAGE_SCOPE: ${env.CHIVUE_PACKAGE_SCOPE}
  GITHUB_ORGANIZATION: ${env.GITHUB_ORGANIZATION}
  """
  if ( BRANCH_NAME != PROD_BRANCH && BRANCH_NAME != "pr-*" ) {
    currentBuild.description = "<a href='https://github.com/${env.GITHUB_ORGANIZATION}/Chi/tree/${BRANCH_NAME}'>${BRANCH_NAME}</a> - <a href='https://${GIT_COMMIT}-chi-pr.enterprise.ctl.io'> WEB </a> : ${BRANCH_NAME}";
  } else if ( BRANCH_NAME != PROD_BRANCH && BRANCH_NAME == "pr-*" && BRANCH_NAME == "PR-*" ) {
    currentBuild.description = "<a href='https://github.com/${env.GITHUB_ORGANIZATION}/Chi/pull/${CHANGE_ID}'>PR#${CHANGE_ID}</a> - <a href='https://${GIT_COMMIT}-chi-pr.enterprise.ctl.io'> WEB </a> : ${PULL_REQUEST}";
  }
}

def createTagging() {
  def tagAttributes = jslGCRGetTagAttributes()
  echo "Processing ${tagAttributes['tagType']} tag for DevOps ${tagAttributes['gcrNumber']}"
  jslGCRTag('PROMOTE', tagAttributes['tsMark'], tagAttributes['gcrNumber'])
  def tagName = jslGCRTag('DEPLOYMENT', tagAttributes['tsMark'], tagAttributes['gcrNumber'])
  def currentJob = env.JOB_NAME.toString()
  def currentBaseName = env.JOB_BASE_NAME.toString()
  def pathJob = currentJob - currentBaseName
  echo "Triggering deployment to production job ${pathJob} with tag ${tagName}"
  jslTriggerRemoteJob(tagName.trim(), "/${pathJob}/".toString(), false, false, 6)
}

def buildChi() {
  dir ('src/chi-vue') {
    unstash name: "DIST-CHI-VUE-UMD"
  }
  sh "sleep 10s"
  dir ('src/custom-elements') {
    unstash name: "DIST-CHI-CE"
  }
  sh "sleep 10s"
  jslYarnWrapper('install')
  jslNpmWrapper('run cicd:build:pre:sri')
  jslNpmWrapper('run sri')
  jslNpmWrapper('run cicd:build:post:sri')
  stash name: "DIST-CHI", includes: "dist/**"
  stash name: "NODEMODULES-CHI", includes: "node_modules/**"
  jslJiraSendBuildInfo()
}

def runBackstopjsResponsiveTest() {
  sh """
    rm -rf dist
    rm -rf node_modules
    rm -rf reports/html_report/responsive
  """
  unstash name: "DIST-CHI"
  unstash name: "NODEMODULES-CHI"
  sh script: """
    mkdir -p reports/html_report/responsive
    cp -a config/backstop_data/bitmaps_reference/responsive reports/html_report/responsive/bitmaps_reference
  """, label: "Copying for executing BackstopJS Responsive tests"
  jslNpmWrapper('run test:backstop:responsive')
  stash name: "BACKSTOP-RES-HTML", includes: "reports/html_report/responsive/**"
  stash name: "BACKSTOP-RES-CI", includes: "reports/ci_report/responsive/**"
  archiveArtifacts artifacts: "reports/html_report/responsive/**", fingerprint: true
  jslPublishTestResults('reports/ci_report/responsive/xunit.xml')
  sh "test ${currentBuild.currentResult} != UNSTABLE"
}

def runBackstopjsNonResponsiveTest() {
  sh """
    rm -rf dist
    rm -rf node_modules
    rm -rf reports/html_report/non_responsive
  """
  unstash name: "DIST-CHI"
  unstash name: "NODEMODULES-CHI"
  sh script: """
    mkdir -p reports/html_report/non_responsive
    cp -a config/backstop_data/bitmaps_reference/non_responsive reports/html_report/non_responsive/bitmaps_reference
  """, label: "Copying for executing BackstopJS Non-Responsive tests"
  jslNpmWrapper('run test:backstop:non-responsive')
  stash name: "BACKSTOP-NON-RES-HTML", includes: "reports/html_report/non_responsive/**"
  stash name: "BACKSTOP-NON-RES-CI", includes: "reports/ci_report/non_responsive/**"
  archiveArtifacts artifacts: "reports/html_report/non_responsive/**", fingerprint: true
  jslPublishTestResults('reports/ci_report/non_responsive/xunit.xml')
  sh "test ${currentBuild.currentResult} != UNSTABLE"
}

def runBackstopjsCustomElementsTest() {
  sh """
    rm -rf dist
    rm -rf node_modules
    rm -rf reports/html_report/non_responsive_ce
  """
  unstash name: "DIST-CHI"
  unstash name: "NODEMODULES-CHI"
  sh script: """
    mkdir -p reports/html_report/non_responsive_ce
    cp -a config/backstop_data/bitmaps_reference/non_responsive reports/html_report/non_responsive_ce/bitmaps_reference
  """, label: "Copying for executing BackstopJS Custom Elements tests"
  jslNpmWrapper('run test:backstop:non-responsive:ce')
  stash name: "BACKSTOP-CE-HTML", includes: "reports/html_report/non_responsive_ce/**"
  stash name: "BACKSTOP-CE-CI", includes: "reports/ci_report/non_responsive_ce/**"
  archiveArtifacts artifacts: "reports/html_report/non_responsive_ce/**", fingerprint: true
  jslPublishTestResults('reports/ci_report/non_responsive_ce/xunit.xml')
  sh "test ${currentBuild.currentResult} != UNSTABLE"
}

def runCypressLocalTesting() {
  sh """
    rm -rf dist
    rm -rf node_modules
  """
  jslYarnWrapper('install')
  jslYarnWrapper('cache clean')
  unstash name: "DIST-CHI"
  dir ('src/custom-elements') {
    sh """
      rm -rf dist
      rm -rf node_modules
    """
    unstash name: "DIST-CHI-CE"
    unstash name: "NODEMODULES-CHI-CE"
  }
  dir ('src/chi-vue') {
    sh """
      rm -rf dist
      rm -rf node_modules
    """
    unstash name: "DIST-CHI-VUE"
    unstash name: "NODEMODULES-CHI-VUE"
  }
  def retries = 3
  while (retries != 0) {
    try {
      jslNpxWrapper('gulp serve 2>&1 >/dev/null &')
      break
    } catch (Exception e) {
      retries -= 1
      echo "failure starting local server // remaining attempts: ${retries}"
    }
  }
  sh script: """
    ./node_modules/.bin/cypress run
  """, label: "Running NPX before adding JSL file, TEST."
  jslNpxWrapper('gulp serve:stop')
}

def uploadCoverageToSonarqube() {
  try {
    unstash name: "COVERAGE"
  }  catch (Exception e) {
    echo "No coverage data"
  }
  unstash name: "BACKSTOP-CE-CI"
  unstash name: "BACKSTOP-NON-RES-CI"
  unstash name: "BACKSTOP-RES-CI"
  jslSonarQubeStaticAnalysis('./cicd/docker/SonarQube/sonar-project.properties', env.SONARQUBE_CREDENTIALS)
}

def runQualityGate1() {
  def isTestAvailable = true
  try {
    unstash name: "BACKSTOP-NON-RES-CI"
  } catch (Exception e) {
    echo "No BACKSTOP-NON-RES-CI tests: ${e.getMessage()}"
    isTestAvailable = false
  }
  if (isTestAvailable) {
    echo "QualityGate1-Unit"
    jslCheckQualityGates('reports/ci_report/non_responsive/xunit.xml', 'QualityGate1-Unit')
  }
  echo "QualityGate1-StaticCodeAnalysis"
  jslAdoptionSonarStats('sonarqubeStats.json')
  jslCheckSonarQualityGate('cicd/qgatethresholds/qgate1-sonar.json', 'sonarqubeStats.json')
  if ("${currentBuild.currentResult}" != "UNSTABLE") {
    jslCheckQualityGates('sonarqubeStats.json', 'QualityGate1-StaticCodeAnalysis', 'sonarqubestats', 'cicd/qgatethresholds/qgate1-sonar.json')
  } else {
    echo "skipping CheckQualityGate of StaticCodeAnalysis: jslCheckSonarQualityGate failed"
  }
}

def runGitHubRelease() {
  sh script: """#!/bin/bash
    VERSION=\$(cat package.json | grep '"version":' | cut -f4 -d '"')
    major=\$(echo \$VERSION | awk -F '.' '{print \$1}')
    minor=\$(echo \$VERSION | awk -F '.' '{print \$2}')
    patch=\$(echo \$VERSION | awk -F '.' '{print \$3}')

    if [[ \$major == 0 ]]
    then
        echo "Major digit Already Zero"
        majorold="0"
    elif [[ \$minor == 0 ]]
    then
        majorold=\$(( \$major - 1 ))
    else
        majorold="\$major"
    fi

    if [[ \$minor == 0 ]]
    then
        echo "Minor digit Already Zero"
        minorold="0"
    elif [[ \$patch == 0 ]]
    then
        minorold=\$(( \$minor - 1 ))
    else
        minorold="\$minor"
    fi

    if [[ \$patch == 0 ]]
    then
        echo "Patch digit Already Zero"
        patchold="0"
    else
        patchold=\$(( \$patch - 1 ))
    fi

    echo "READING CHANGELOG FOR VERSION: \$major.\$minor.\$patch"
    echo "v\$major.\$minor.\$patch" > shortCHANGELOG.md
    echo "" >> shortCHANGELOG.md
    sed -n -e "/\$major.\$minor.\$patch/,/\$majorold.\$minorold.\$patchold/ p" CHANGELOG.md | head -n -2 >> shortCHANGELOG.md
  """
  env.VERSION = sh (
    script: """
      cat package.json | grep '"version":' | cut -f4 -d '"'
    """,
    returnStdout: true
  ).trim()
  jslHubWrapper("release create -F shortCHANGELOG.md v${env.VERSION}")
}

def publishToS3() {
  sh "rm -rf dist"
                unstash name: "DIST-CHI"
                def s3Uri = "${GIT_COMMIT}-chi-pr-po-ctl"
                sh script:"""
                  cat << 'PolicyDocument' > policy.json
{
   "Statement": [
      {
         "Effect": "Allow",
         "Principal": "*",
         "Action": "s3:GetObject",
         "Resource": "arn:aws:s3:::${s3Uri}/*"
      }
   ]
}
PolicyDocument
                """, label: "Policy.json"

  jslAwsCliWrapper("s3api create-bucket --bucket ${s3Uri} --acl public-read", 'us-east-1', true)
  jslAwsCliWrapper("s3api put-bucket-policy --bucket ${s3Uri} --policy file://policy.json", 'us-east-1', true)
  jslAwsCliWrapper("s3api get-bucket-policy --bucket ${s3Uri}", 'us-east-1', true)
  jslAwsCliWrapper("s3 cp ./dist s3://${s3Uri} --recursive", 'us-east-1', true)
  jslAwsCliWrapper("s3 website s3://${s3Uri} --index-document index.html --error-document index.html", 'us-east-1', true)


  // sh "sleep 10m"
  // jslAwsCliWrapper("s3 rb ${s3Uri} --force", 'us-east-1', true)
  echo "This will publish dev build to S3"
}

def publishToK8s() {
  sh "rm -rf dist"
  unstash name: "DIST-CHI"
  jslBuildAndPushToNexus('./cicd/docker/nginx/Dockerfile')

  def chiManifest = 'chiManifest.yml'
  def chiManifestFile = "./${chiManifest}"
  sh "rm -rf ${chiManifestFile}"
  jslGenerateManifestForSimpleNginx(chiManifestFile)
  jslDeployK8s(chiManifestFile)
  archiveArtifacts artifacts: chiManifest, fingerprint: true

  echo "This will publish dev build to K8s"
  if (env.CHANGE_ID != null) {
    echo "Sending Jira Deployment for DEV"
    jslDeploymentContractValidationWrite("development")
    jslJiraSendDeploymentInfo('development', true)
  }
}

def publishAssetServerBuild() {
  sh "rm -rf dist node_modules"
  unstash name: "DIST-CHI"
  sh script:"""
    sed -i 's#/getting-started#getting-started#g' dist/index.html

    cat ${WORKSPACE}/CHANGELOG.md

    if [ -e "${WORKSPACE}/ux-chi-AssetsServer" ];
    then
      rm -rf ${WORKSPACE}/ux-chi-AssetsServer
    fi
  """, label: "Cleaning before pushing to AssetsServer"
  jslGitHubCloneRepo('ux-chi-AssetsServer')
  env.CHECK = sh (
    script: """#!/bin/bash
      VERSION=\$(cat package.json | grep '"version":' | cut -f4 -d '"')
      if [[ -d ux-chi-AssetsServer/chi/\$VERSION ]]
      then
          check="EXISTS"
      else
          check="NO"
      fi
      echo "\$check"
    """,
    returnStdout: true
  ).trim()

  echo "PlaceHolder for ASSET Server Push of CHI version"
  sh script:"""
    ls -lah
    VERSION=\$(cat package.json | grep '"version":' | cut -f4 -d '"')
    echo \${VERSION}
    cat << PRDesc > ux-chi-AssetsServer/prepared-message.md
This PR is for CHI \${VERSION}

You can check staging in https://assets-dev.ctl.io/chi/staging
PRDesc
    mkdir -p ${WORKSPACE}/ux-chi-AssetsServer/chi/latest
    cp -R ${WORKSPACE}/dist/* ${WORKSPACE}/ux-chi-AssetsServer/chi/latest/
    mv ${WORKSPACE}/dist ${WORKSPACE}/ux-chi-AssetsServer/chi/\$VERSION
    cd ${WORKSPACE}/ux-chi-AssetsServer
    git checkout -b "CHI_\$VERSION"
    git add ${WORKSPACE}/ux-chi-AssetsServer/chi/\$VERSION
    git add ${WORKSPACE}/ux-chi-AssetsServer/chi/latest
    git config user.email "scmauto@lumen.com"
    git config user.name "SCMAUTO"
    git commit -m "CHI_\$VERSION"
    git push -f origin CHI_\$VERSION
  """, label: "Pushing branch to AssetsServer"
  if ( env.CHECK == "NO" ) {
    dir ('ux-chi-AssetsServer') {
      jslHubWrapper('pull-request -F prepared-message.md')
    }
  } else {
    echo "NO PR CREATED THIS TIME; REQUIRES VERSION BUMP"
  }
  if (env.TAG_NAME && env.TAG_NAME.toString().indexOf("##DEPLOYMENT##") != -1) {
    def previousDeploymentCommit = jslGCRTagCommit('DEPLOYMENT', 2)
    def changeLog = jslAuditChangelog(true, env.GIT_COMMIT, previousDeploymentCommit)
    echo "Sending Jira Deployment changeLog for PROD: ${changeLog}"
    jslDeploymentContractValidationWrite("production")
    jslJiraSendDeploymentInfo('production', true, env.BRANCH_NAME, changeLog)
  } else {
    def lastDeploymentCommit = jslGCRTagCommit()
    def changeLog = jslAuditChangelog(true, env.GIT_COMMIT, lastDeploymentCommit)
    echo "Sending Jira Deployment changeLog for STAGING: ${changeLog}"
    jslDeploymentContractValidationWrite("staging")
    jslJiraSendDeploymentInfo('staging', true, env.BRANCH_NAME, changeLog)
  }
}

def runSmokeTests() {
  sh "rm -rf cypress/reports/smokeTests && mkdir -p cypress/reports/smokeTests"
  if (env.VERSION != null) {
    echo "Starting SMOKE TESTS with the published release ${env.VERSION}"

    def latestRelease = ""
    withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: env.GITHUB_TOKEN_CREDENTIALS,
                      usernameVariable: 'USERNAME', passwordVariable: 'ACCESS_TOKEN']]) {
      try {
        latestRelease = sh script: """
          curl -s -H "Authorization: token \${ACCESS_TOKEN}" "https://api.github.com/repos/${env.GITHUB_ORGANIZATION}/chi/releases/latest" | grep '"name":' | cut -d: -f 2,3 | tr -d '"' | tr -d ','
          """, label: 'Getting Latest Release Version', returnStdout: true
          latestRelease = latestRelease.trim()
      } catch (Exception e) {
        echo "Error checking chi releases: ${e.getMessage()}"
      }
    }

    jslGenerateManualTestReport("Version Release", "Check Version", "v${env.VERSION}", (latestRelease == "v${env.VERSION}").toBoolean(), 1.0, "cypress/reports/smokeTests/smoke_test_result.xml")
    env.SMOKE_TEST_FAILURE = (latestRelease != "v${env.VERSION}")
    echo "Smoke Test Failure? ${env.SMOKE_TEST_FAILURE}"
  } else {
    echo "Smoke Test hook without release"
    jslGenerateManualTestReport("Change without Release", "Hook test", "hookTest", true, 1.0, "cypress/reports/smokeTests/smoke_test_result.xml")
  }

  stash name: 'smokeTests', includes:"cypress/reports/smokeTests/**"
  jslPublishTestResults('cypress/reports/smokeTests/**')
}

def runAdoptionStats() {
  if (env.TAG_NAME && env.TAG_NAME.toString().indexOf("##DEPLOYMENT##") != -1) {
    env.DEVOPS_GCR_PREPROD_BRANCH = 'master'
    unstash name: "smokeTests"
    zip zipFile: 'smoke_tests.zip', dir: "cypress/reports/smokeTests"
    if (env.SMOKE_TEST_FAILURE != null && env.VERSION != null) {
      //DevOpsGCR with release Version
      echo "updating DevOpsGCR"
      if (env.SMOKE_TEST_FAILURE == "false") {
        echo "release successfully created"
        jslGCRDevOpsUpdate('SUCCEEDS', ['smoke_tests.zip'])
      } else {
        echo "failures creating release!"
        jslGCRDevOpsUpdate('FAILED', ['smoke_tests.zip'], "SmokeTests failed after release creation")
      }
    }
    echo "Adding smoke Tests / smoke Test hook to Adoption Stats"
    jslAdoptionMain('cypress/reports/smokeTests/*.xml')

  } else {
    try {
      sh """
        rm -rf reports/ci_report/*
      """
      unstash name: "BACKSTOP-CE-CI"
      unstash name: "BACKSTOP-NON-RES-CI"
      unstash name: "BACKSTOP-RES-CI"
      sh """
        cat reports/ci_report/responsive/xunit.xml > reports/ci_report/xunitfinal.xml
        cat reports/ci_report/non_responsive/xunit.xml >> reports/ci_report/xunitfinal.xml
        cat reports/ci_report/non_responsive_ce/xunit.xml >> reports/ci_report/xunitfinal.xml
      """
      echo "No E2E results found, reporting only unit"
    } catch (Exception exc) {
      echo "No regression tests present and no AdoptionMain Stats neither DevOps GCR"
      sh """
        mkdir -p reports/ci_report
        touch reports/ci_report/xunitfinal.xml
      """
    }
    if (isVersionBump()) {
      //Set variable to trigger DevOps GCR Creation
      env.DEVOPS_GCR_PREPROD_BRANCH = 'master'
    }
    jslAdoptionMain('reports/ci_report/xunitfinal.xml')
  }
}

def createBranchChiVue() {
  withCredentials([usernamePassword(credentialsId: env.GITHUB_TOKEN_CREDENTIALS, usernameVariable: 'USERNAME', passwordVariable: 'ACCESS_TOKEN')]){
    def projectJson = readJSON file: 'src/chi-vue/package.json', returnPojo: true;
    def version = projectJson["version"];
    def versionReturn = projectJson["version"];
    jslGitHubCloneRepo("po-enterprise-shell", "CenturyLink", "master", env.GITHUB_TOKEN_CREDENTIALS)
    def shellJson = readJSON file: 'po-enterprise-shell/package.json', returnPojo: true;
    if (shellJson["dependencies"]["@centurylink/chi-vue"] != null) {
      updateBranchChiVue(version)
    }
    return versionReturn
  }
}

def updateBranchChi(version) {
  sh (script: """
      cd po-enterprise-shell
      git fetch -p
      git branch -D chi-new-version-${version} || echo "Branch was not there"
      git push origin --delete chi-new-version-${version} || echo "Branch was not there"
      git checkout -b chi-new-version-${version}
      git push -u origin chi-new-version-${version}
    """, label: "Changes for PR in shell to upgrade Chi", returnStdout: true)
}

def updateBranchChiVue(version) {
  sh(script: """
      cd po-enterprise-shell
      git fetch -p
      git branch -D chi-vue-new-version-${version} || echo "Branch was not there"
      git push origin --delete chi-vue-new-version-${version} || echo "Branch was not there"
      git checkout -b chi-vue-new-version-${version}
      git push -u origin chi-vue-new-version-${version}
    """, label: "Changes for PR in shell to upgrade chi vue")
}

def createBranchChi() {
  withCredentials([usernamePassword(credentialsId: env.GITHUB_TOKEN_CREDENTIALS, usernameVariable: 'USERNAME', passwordVariable: 'ACCESS_TOKEN')]){
    def projectJson = readJSON file: 'package.json', returnPojo: true;
    def version = projectJson["version"];
    jslGitHubCloneRepo("po-enterprise-shell", "CenturyLink", "master", env.GITHUB_TOKEN_CREDENTIALS)
    updateBranchChi(version);
    return version
  }
}

def deleteShellFolder() {
  sh(script: """
  rm -rf po-enterprise-shell
  """)
}

def pushBranchChiVue(version) {
  withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: env.GITHUB_TOKEN_CREDENTIALS,
                   usernameVariable: 'USERNAME', passwordVariable: 'ACCESS_TOKEN']]) {
    sh(script: """
        set +x
        git config credential.helper  "!f() {echo username=${env.USERNAME}; echo password=${env.ACCESS_TOKEN}; }"
        git config --global user.email "cicdint0@lumen.com"
        cd po-enterprise-shell
        git status
        git add package-lock.json package.json
        git commit -m "New version on ${env.PROJECT_NAME}: ${version}"
        git push https://\${USERNAME}:\${ACCESS_TOKEN}@github.com/CenturyLink/po-enterprise-shell.git
        """, returnStdout: true, label: 'pushBranchChiVue')
  }
}

def pushBranchChi(version) {
  withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: env.GITHUB_TOKEN_CREDENTIALS,
                    usernameVariable: 'USERNAME', passwordVariable: 'ACCESS_TOKEN']]) {
  sh(script: """
    set +x
    git config credential.helper "!f() {echo username=${env.USERNAME}; echo password=${env.ACCESS_TOKEN}; }"
    git config --global user.email "cicdint0@lumen.com"
    cd po-enterprise-shell
    git status
    git add .env
    git commit -m "New Chi version: ${version}"
    git push https://\${USERNAME}:\${ACCESS_TOKEN}@github.com/CenturyLink/po-enterprise-shell.git
  """, returnStdout: true)
  }
}

def updateChiVueOnShell() {
  def shellJson = readJSON file: 'po-enterprise-shell/package.json', returnPojo: true;
  def projectJson = readJSON file: 'src/chi-vue/package.json', returnPojo: true;
  def version = projectJson["version"];
  if (version != null && version != "" && shellJson["dependencies"]["@centurylink/chi-vue"] != null) {
    shellJson["dependencies"]["@centurylink/chi-vue"] = version
    writeJSON file: 'po-enterprise-shell/package3.json', json: shellJson, pretty: 2
    sh(script: """
    ls -l
    ls -l po-enterprise-shell
    rm -f po-enterprise-shell/package.json po-enterprise-shell/package2.json
    mv po-enterprise-shell/package3.json po-enterprise-shell/package.json
    """, returnStdout: true)
    return true
    
    
  }
  return false
}

def parserEnv(newVersion) {
  def filePath = "po-enterprise-shell/.env"
  def fileDestiny = "po-enterprise-shell/.env2"
  def fileBegin = readFile filePath
  def completeStr = ""
  list = fileBegin.readLines()
  list.each {
    info = it.split("=")
    if (info[0] == "VUE_APP_CHI_VERSION") {
        completeStr = completeStr + "VUE_APP_CHI_VERSION=${newVersion}\n"
      } else if (info[0] == "VUE_APP_CHI_CSS_VERSIONS_ALLOWED") {
        def oldVersions = info[1].trim()
        completeStr = completeStr + "VUE_APP_CHI_CSS_VERSIONS_ALLOWED=${oldVersions},${newVersion}\n"
      } else {
        completeStr = completeStr + "${it}" + "\n"
      }
  }
  writeFile file: fileDestiny, text: completeStr
}

def updateChiOnShell() {
  def projectJson = readJSON file: 'package.json', returnPojo: true;
  def version = projectJson["version"]
  parserEnv(version)
  sh(script: """
  ls -l
  echo "${version}"
  export VERSION_UPDATE_CHI_SHELL=${version}
  cat po-enterprise-shell/.env2
  rm po-enterprise-shell/.env
  mv po-enterprise-shell/.env2 po-enterprise-shell/.env
  """, returnStdout: true)
}

def createPRInShellVueChi() {
  unstash name: "VERSION_BUMP_VUE_CHI"
  def changed = readFile file: "version_bump_vue_chi"
  if (changed.trim() == "yes") {
    def result = false
    def version = ""
    version = createBranchChiVue()

    result = updateChiVueOnShell()
    if (result) {
      publishAutoPRChiVue(version)
    }
    deleteShellFolder()
  }
}

def publishAutoPRChiVue(version) {
  dir("po-enterprise-shell") {
    jslNpmWrapper("install", env.GITHUB_TOKEN_SHELL_CREDENTIALS)
  }
  pushBranchChiVue(version)
  if (version != "") {
    configFileProvider([configFile(fileId: 'jira-ticket-auto-pr', variable: 'configFileJira')]) {
      def props = readProperties file: "$configFileJira"
      def ticket = props['ticket']
      def titleName = "${ticket} Update chi-vue to version ${version}"
      def bodyString = "Update ${env.PROJECT_NAME} version to ${version}"
      def headName = "chi-vue-new-version-${version}"
      def baseName = "master"
      def githubCredentials = env.GITHUB_TOKEN_CREDENTIALS
      def repoPR = "po-enterprise-shell"
      jslGitHubPRCreate(titleName, bodyString, headName, baseName, githubCredentials, repoPR)
    }
  }
}

def createPRInShellChi() {
  unstash name: "VERSION_BUMP"
  def changed = readFile file: "version_bump"
  if (changed.trim() == "yes") {
    def result = false
    def version = ""
    version = createBranchChi()
    result = updateChiOnShell()
    if (result) {
      publishAutoPRChi(version)
    }
  }
  deleteShellFolder()
}

def publishAutoPRChi(version) {
  pushBranchChi(version)
  if (version != "") {
    configFileProvider([configFile(fileId: 'jira-ticket-auto-pr', variable: 'configFileJira')]) {
      def props = readProperties file: "$configFileJira"
      def ticket = props['ticket']
      def titleName = "${ticket} Update chi version to ${version}"
      def bodyString = "Update chi version to ${version}"
      def headName = "chi-new-version-${version}"
      def baseName = "master"
      def githubCredentials = env.GITHUB_TOKEN_CREDENTIALS
      def repoPR = "po-enterprise-shell"
      jslGitHubPRCreate(titleName, bodyString, headName, baseName, githubCredentials, repoPR)
    }
  }
}

def check_pack() {
  sh(script: """
    set +x
    git whatchanged -1 --format=oneline
    git diff HEAD~2 package.json | grep '"version":' || echo No package.json changes
    rm -rf version_bump
    if [ \$(git diff HEAD~2 package.json | grep '"version":' | wc -l) -eq 2 ]; then
      echo "change in package.json"
      echo -n "yes" > version_bump
    else
      echo "no change in package.json"
      echo -n "no" > version_bump
    fi
    cat version_bump
    """, label: "Package version validation")
}

def check_vue_pack() {
  sh(script: """
  set +x
  git diff HEAD~2 src/chi-vue/package.json | grep '"version":' || echo No chi-vue package.json changes
    rm -rf version_bump_chi_vue
    if [ \$(git diff HEAD~2 src/chi-vue/package.json | grep '"version":' | wc -l) -eq 2 ]; then
      echo -n "yes" > version_bump_vue_chi
      echo "change in chi-vue"
    else
      echo -n "no" > version_bump_vue_chi
      echo "no change in chi-vue"
    fi
    echo "All good."
    """, label: "Package version validation")
}

def check_package() {
  check_pack()
  check_vue_pack()
}
